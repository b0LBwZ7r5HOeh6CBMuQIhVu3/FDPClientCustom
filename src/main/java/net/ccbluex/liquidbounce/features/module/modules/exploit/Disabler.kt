//  updated at : 2022/1/28.
//

package net.ccbluex.liquidbounce.features.module.modules.exploit

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotifyType
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.RotationUtils
import net.ccbluex.liquidbounce.utils.PlayerUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.ccbluex.liquidbounce.value.TextValue
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.Vec3
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.*
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {
    private val modeValue = ListValue("Mode", arrayOf("MineplexCombat","VulcanCombat", "OldVerusCombat", "OldVerusCombat2", "OldVerusMove", "VerusAirlines", "Flying", "Riding", "Spectate", "SpectateV2", "SpectateSpoof", "Payload", "ridingv2", "SpectateSpoof2", "ghostly", "LessFlag", "C13+InfiniteC0C", "NoGroundTouch", "OldMatrix", "Kauri", "FakeLag", "Hypixel", "HuayutingVelocityTest", "Hypixel2", "BlocksMC"), "MinePlexCombat")
    private val debug = BoolValue("Debug", false)
    private val memeAACValue = BoolValue("OldMatrixWithAAC5", false).displayable { modeValue.equals("OldMatrix") }
    private val fakeLagPosValue = BoolValue("FakeLagPosition", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagBlockValue = BoolValue("FakeLagBlock", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagAttackValue = BoolValue("FakeLagAttack", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagSpoofValue = BoolValue("FakeLagC03Spoof", false).displayable { modeValue.equals("FakeLag") }
    private val watchDogAntiBan = BoolValue("WatchDog Disabler", false).displayable { modeValue.equals("Hypixel") }
    private val lagDelayValue = IntegerValue("LagDelay", 0, 0, 2000).displayable { modeValue.equals("FakeLag") }
    private val lagDurationValue = IntegerValue("LagDuration", 200, 100, 1000).displayable { modeValue.equals("FakeLag") }
    private val verusSlientFlagApplyValue = BoolValue("VerusSlientFlagApply", false).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("VerusAirlines") }
    private val verusBufferSizeValue = IntegerValue("VerusBufferSize", 300, 0, 1000).displayable { modeValue.equals("VerusAirlines") }
    private val verusKeepAliveValue = BoolValue("VerusKeepAlive", false).displayable { modeValue.equals("VerusAirlines") }
    private val verusFlagDelayValue = IntegerValue("Verus-FlagDelay", 40, 35, 60).displayable { modeValue.equals("VerusAirlines") }
    private val verusPurseDelayValue = IntegerValue("verusPurseDelayValue", 450, 200, 660).displayable { modeValue.equals("VerusAirlines") }
    private val verusRepeatTimesValue = IntegerValue("Verus-RepeatTimes", 1, 1, 5).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("VerusAirlines") }
    private val payloadMessageValue = TextValue("payloadMessage", "Vulcan:geyser")

    // private val verusSlientFlagApplyValue = BoolValue("VerusSlientFlagApply", false).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("LatestVerus") }
    // private val verusBufferSizeValue = IntegerValue("VerusBufferSize", 300, 0, 1000).displayable { modeValue.equals("LatestVerus") }
    private val verusRepeatTimesFightingValue = IntegerValue("Verus-RepeatTimesFighting", 1, 1, 5).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("VerusAirlines") }
    // private val verusFlagDelayValue = IntegerValue("Verus-FlagDelay", 40, 35, 60).displayable { modeValue.equals("LatestVerus") }
    // private val verusRepeatTimesValue = IntegerValue("Verus-RepeatTimes", 1, 1, 5).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("LatestVerus") }

    private var lastReportedPosition = Vec3(0.0, 0.0, 0.0)
    private var verus2Stat = false
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private var currentTrans = 0
    private var memeTick = 0
    private var vulTickCounterUID = -25767
    /*
        Discovered on April 17th
        
        -25767 step = -1 / 250ms(5 ticks)
        Vulcan TickCounter(C0F PingCheck) - AimA AimB AimD AimF TimerC
        
        -30000 step = 0 onRespawn/onWorldChange
        Vulcan Respawn - S08Respond(Prevent FalsePositives)
        
        Guess them yourself:
        
        -??767 step = -1 onVelocitySend
        Vulcan Velocity Respond(Prevent FalsePositives) - Speed Flight
        
        -??767/-??767 step = -1 onPotionEffectApply
        Vulcan PotionEffect Give/End - EffectTimer Sync(Prevent FalsePositives) - SpeedC/D
    */
    private var isSent = false
    private var needTP = false
    private val fakeLagDelay = MSTimer()
    private val HypixelDebug = MSTimer()
    private val fakeLagDuration = MSTimer()
    private var lastTick = 0
    private var tick = 0
    private var packetCount = 0;
    private var packets = 0;
    private val repeatTimes: Int
        get() = if (LiquidBounce.combatManager.inCombat) {
            verusRepeatTimesFightingValue.get()
        } else {
            verusRepeatTimesValue.get()
        }

    private var counter = 0
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0
    private var expectedTeleport = false
    fun shouldRun(): Boolean = mc.thePlayer != null && mc.thePlayer.ticksExisted > 5
    fun isInventory(action: Short): Boolean = action > 0 && action < 100
    private var modified = false
    override fun onEnable() {
        if(modeValue.get().lowercase() == "vulcancombat") {
            alert("§8[§aDisabler§8] §r§aVulcanCombat Disabler §c§lONLY §r§awork when you rejoined the server!")
        }
        reset()
    }

    override fun onDisable() {
        modified = false
        when (modeValue.get().lowercase()) {
            "oldmatrix" -> {
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "fakelag" -> {
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "hypixel" -> {
                counter = 0
            }
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        reset()
    }

    private fun reset() {
        memeTick = 0
        currentTrans = 0
        verus2Stat = false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
        counter = 0
        packets = 0
        tick = 0
        lastReportedPosition = Vec3(0.0, 0.0, 0.0)
        packetCount = 0
        fakeLagDelay.reset()
        vulTickCounterUID = -25767
    }

    @EventTarget
    fun onTick(event: TickEvent) {
        when (modeValue.get().lowercase()) {
            "blocksmc" -> {
                if (mc.thePlayer.ticksExisted % 8 === 0) {
                    debugMessage("tick")
                    val deltaX: Double = Math.abs(mc.thePlayer.posX - lastReportedPosition.xCoord)
                    val deltaY: Double = Math.abs(mc.thePlayer.posY - lastReportedPosition.yCoord)
                    val deltaZ: Double = Math.abs(mc.thePlayer.posZ - lastReportedPosition.zCoord)
                    val diff = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ)
                    if (diff > 2.0 || tick - packets > 200) {
                        lastReportedPosition = Vec3(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                        var packet: C06PacketPlayerPosLook? = null
                        var y: Double = mc.thePlayer.posY
                        if (y % 1.0 > 0.25) {
                            y = (mc.thePlayer.posY as Int + 1).toDouble()
                        }
                        packet = if (RotationUtils.getKeepLength() > 0) {
                            C06PacketPlayerPosLook(mc.thePlayer.posX, y, mc.thePlayer.posZ, RotationUtils.targetRotation.yaw, RotationUtils.targetRotation.pitch, true)
                        } else {
                            C06PacketPlayerPosLook(mc.thePlayer.posX, y, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, true)
                        }
                        PacketUtils.sendPacketNoEvent(packet)
                        packets = tick
                        ++packetCount
                    }
                }
            }
        }
    }


    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        modified = false
        when (modeValue.get().lowercase()) {
            "oldveruscombat2" -> {
                mc.timer.timerSpeed = 0.6F
                if (mc.thePlayer.ticksExisted % 50 == 0 && (packetBuffer.size - 1) > currentTrans) {
                    verus2Stat = true
                    PacketUtils.sendPacketNoEvent(packetBuffer[++currentTrans])
                    debugMessage("Send Trans")
                }
                if (mc.thePlayer.ticksExisted % 500 == 0) {
                    packetBuffer.clear()
                    debugMessage("Clear Trans")
                    currentTrans = 0
                }
            }

            "hypixel" -> {
                if(mc.thePlayer.onGround && PlayerUtils.isBlockUnder() && mc.thePlayer.fallDistance > 10){
                    mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0,1000)))
                    debugMessage("Hypixel Disabler C00")
                }
                if(mc.thePlayer.ticksExisted % 180 == 90){
                    if(mc.thePlayer.onGround && mc.thePlayer.fallDistance > 10){
                        mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0,1000)))
                        debugMessage("Hypixel Disabler C0B")
                        mc.timer.timerSpeed=0.8f;
                    }else{
                        if(mc.thePlayer.fallDistance<10) {
                            if (mc.thePlayer.posY == mc.thePlayer.fallDistance.toDouble()) {
                                mc.netHandler.addToSendQueue(C03PacketPlayer(false))
                                if(mc.thePlayer.onGround) mc.timer.timerSpeed = 0.4f;
                                if(mc.thePlayer.fallDistance==0f) mc.netHandler.addToSendQueue(C03PacketPlayer(true))
                                debugMessage("Hypixel Disabler C03")
                            }
                        }
                    }
                }
                if(mc.thePlayer.posY != 0.0){
                    val times=10000 / if(mc.thePlayer.fallDistance.toLong() != 0L) mc.thePlayer.fallDistance.toLong() else 1
                    if(HypixelDebug.hasTimePassed(if(times<100) 100 else times) && !mc.thePlayer.onGround && mc.thePlayer.fallDistance != 0f){
                        HypixelDebug.reset()
                        debugMessage("Hypixel Disabler Watchdog")
                    }else{
                        if(mc.thePlayer.fallDistance == 0f) HypixelDebug.reset()
                    }
                    if (mc.thePlayer.getItemInUseDuration() >= 1 && PlayerUtils.isUsingFood()) {
                        mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                    }else{
                        mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                    }
                }
            }

            "ridingv2" -> {
                if (lastTick != mc.thePlayer.ticksExisted) {
                    PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, mc.thePlayer.onGround))
                    mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing.coerceAtMost(0.98F), mc.thePlayer.moveForward.coerceAtMost(0.98F), mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
                    PacketUtils.sendPacketNoEvent(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.OPEN_INVENTORY))
                    lastTick = mc.thePlayer.ticksExisted
                    // debug("riding")
                }
            }
            "oldverusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    // grab packets untill the queue size is 22 or less.
                    while (packetBuffer.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        PacketUtils.sendPacketNoEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            "ghostly" -> {
                if (packetBuffer.size > 25) {
                    while (packetBuffer.size > 0) {
                        PacketUtils.sendPacketNoEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            "verusairlines" -> {
                if (fakeLagDelay.hasTimePassed(verusPurseDelayValue.get().toLong()) && verus2Stat) {
                    fakeLagDelay.reset()
                    if (packetBuffer.isNotEmpty()) {
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                        debugMessage("RELEASE")
                    } else {
                        debugMessage("RELEASE BUT EMPTY")
                    }
                }
            }

            "oldmatrix" -> {
                memeTick++
                val cTick = if (memeAACValue.get()) {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 10).roundToInt()
                } else {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 7.6).roundToInt()
                }
                if (memeTick >= cTick) {
                    memeTick = 0
                    for (packet in packetBuffer) {
                        PacketUtils.sendPacketNoEvent(packet)
                    }

                    debugMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }
            
            "vulcancombat" -> {
                if(fakeLagDelay.hasTimePassed(5000L) && packetBuffer.size > 4) {
                    fakeLagDelay.reset()
                    while (packetBuffer.size > 4) {
                        PacketUtils.sendPacketNoEvent(packetBuffer.poll())
                    }
                }
            }

            "fakelag" -> {
                if (!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                // Send
                if (fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for (packet in packetBuffer) {
                        PacketUtils.sendPacketNoEvent(packet)
                    }
                    debugMessage("Release buf(size=${packetBuffer.size})")
                    isSent = true
                    packetBuffer.clear()
                }
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        when (modeValue.get().lowercase()) {
            "mineplexcombat" -> {
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key - RandomUtils.nextInt(1000, 2147483647)))
                    debugMessage("Packet C00")
                }
            }
            "blocksmc" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                }
                if (packet is C00PacketKeepAlive) packet.key *= -1

                if (verusFlagDelayValue.get() > 0) {
                    if (mc.thePlayer!!.ticksExisted % verusFlagDelayValue.get() == 0 && lastTick != mc.thePlayer!!.ticksExisted) {
                        lastTick = mc.thePlayer!!.ticksExisted
                        needTP = true
                    }
                    if (packet is C03PacketPlayer && (packet is C04PacketPlayerPosition || packet is C06PacketPlayerPosLook)) {
                        if (needTP) {
                            packet.y -= 11.015625
                            needTP = false
                            return
                        }
                        packet.y += 0.015625
                    }
                }
            }
            "lessflag" -> {
                if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                        debugMessage("Flag Reduced")
                    } else {
                        debugMessage("Too Far Away")
                    }
                }
            }
            "ridingv2" -> {
                if (packet is C03PacketPlayer || packet is C0BPacketEntityAction) event.cancelEvent()
            }
//            "verussemi" -> {
//                if (packet is C03PacketPlayer) {
//                    packet.onGround = if(packet.isMoving) {
//                        (verusLastY == packet.y && mc.thePlayer.motionY <= 0).also { verusLastY = packet.y }
//                    } else {
//                        true
//                    }
//                    chat("OG ${packet.onGround} ${verusLastY}")
//                }
//            }

            "huayutingvelocitytest" -> {
                if (packet is C03PacketPlayer) {
                    packet.y += 0.11451419198f
                }
            }

            "oldveruscombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if (packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
            }

            "oldveruscombat2" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (!verus2Stat) {
                        packetBuffer.add(packet)
                        debugMessage("Add Packet")
                        event.cancelEvent()
                    } else {
                        verus2Stat = false
                    }
                } else if (packet is C00PacketKeepAlive) {
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(RandomUtils.nextInt(1, 2147483647)))
                    debugMessage("Keep Alive")
                    event.cancelEvent()
                } else if (packet is C03PacketPlayer) {
                    PacketUtils.sendPacketNoEvent(C0CPacketInput())
                    if (mc.thePlayer.ticksExisted % 15 == 0) {
                        packet.y += RandomUtils.nextInt(100, 1000)
                        debugMessage("Packet C03")
                    }
                }
            }
            "payload" -> if (packet is C03PacketPlayer && mc.thePlayer!!.ticksExisted % 10 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.getName())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload(payloadMessageValue.get(), buf))
                } catch (e: IOException) {

                }
            }
/*            public void authenticate(String username){
    ByteArrayOutputStream b = new ByteArrayOutputStream();
    DataOutputStream out = new DataOutputStream(b);
    out.writeUTF("AutoLogin");
    out.writeUTF(username);
    PacketBuffer buffer = (new PacketBuffer(Unpooled.buffer()));
    buffer.writeBytes(b.toByteArray());
    mc.thePlayer.sendQueue.addToSendQueue(new C17PacketCustomPayload("BAuthMeBridge", buffer));
            
}*/
/*             "idk" -> {
                 try {
                  val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF("AutoLogin")
                    _out.writeUTF(idkMessageValue.get())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("BAuthMeBridge", buf))
                } catch (e: IOException) {

                }
            }*/
            "oldverusmove" -> {
                if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0) packetBuffer.clear()
                if (packet is C03PacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                } else if (packet is C0FPacketConfirmTransaction) {
                    repeat(repeatTimes) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                        event.cancelEvent()
                    }
                }
            }

            "verusairlines" -> {
                if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                    packetBuffer.add(packet)
                    event.cancelEvent()
                    if (packetBuffer.size > verusBufferSizeValue.get()) {
                        if (!verus2Stat) {
                            verus2Stat = true
                            LiquidBounce.hud.addNotification(Notification(name, "Successfully put Verus into sleep.", NotifyType.SUCCESS, 10000))
                        }
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                    }
                    debugMessage("C0F, ${packetBuffer.size}")
                } else if (packet is C00PacketKeepAlive && verusKeepAliveValue.get()) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key - RandomUtils.nextInt(1000, 2147483647)))
                    //packet.key better
                    debugMessage("EDIT C00")
                } else if (packet is C03PacketPlayer) {
                    if (mc.thePlayer.ticksExisted % 5 == 0) {
/*                            for (i in 0..8) {
                                // find a empty inventory slot
                                if(mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                                    PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
                                    debugMessage("found empty slot $i, switching")
                                    break
                                }
                            }
                        // PacketUtils.sendPacketNoEvent(C0CPacketInput())
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer())*/
                        // PacketUtils.sendPacketNoEvent(C08PacketPlayerBlockPlacement(BlockPos(mc.thePlayer.posX, mc.thePlayer.posY - 1.5, mc.thePlayer.posZ), 1, ItemStack(Blocks.stone.getItem(mc.theWorld, BlockPos(-1, -1, -1))), 0f, 0.94f, 0f))
                        // PacketUtils.sendPacketNoEvent(C03PacketPlayer())
                        // PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                    }
                    // val yPos = (mc.thePlayer.posY * 64.0).roundToInt() / 64.0
                    // mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0/* && !expectedTeleport*//* && lastTick != mc.thePlayer.ticksExisted*/) {

                        debugMessage("C03 MODIFY")
                        packet.y -= 11.015625
                        memeTick = 1
                        // switchTP = !switchTP
                        packet.onGround = false
                        packet.isMoving = false
                        // packet.isMoving = false
                        expectedTeleport = true
                        lastTick = mc.thePlayer.ticksExisted
                        if (memeTick > 0) {
                            if (memeTick > 2) {
                                memeTick = 0
                                return
                            } else {
                                packet.y = if (memeTick % 2 == 0) 256.00114514 else 3.015625
                                packet.onGround = false
                                packet.isMoving = false
                            }
                            memeTick++
                            expectedTeleport = true
                        }
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)

                    if (diff <= 8 || expectedTeleport) {
                        event.cancelEvent()
                        expectedTeleport = false
                        debugMessage("flag silent accept")
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                }
                /*else if (packet is C0BPacketEntityAction) {
               event.cancelEvent()
               // debug("ignored packet action")
           }*/

                if (mc.thePlayer != null && mc.thePlayer.ticksExisted <= 7) {
                    fakeLagDelay.reset()
                    packetBuffer.clear()
                }
            }
            
            "vulcancombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (Math.abs((Math.abs((packet.uid).toInt()).toInt() - Math.abs(vulTickCounterUID.toInt()).toInt()).toInt()) <= 4) {
                        vulTickCounterUID = (packet.uid).toInt()
                        packetBuffer.add(packet)
                        event.cancelEvent()
                        debugMessage("C0F-PingTickCounter IN ${packetBuffer.size}")
                    }else if (Math.abs((Math.abs((packet.uid).toInt()).toInt() - 25767).toInt()) <= 4) {
                        vulTickCounterUID = (packet.uid).toInt()
                        debugMessage("C0F-PingTickCounter RESETED")
                    }
                }
            }

            "kauri" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                }
            }

            "riding" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
                }
            }
            // "spectate" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
            "spectatev2" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(UUID.randomUUID()))
            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                }
            }

            "nogroundtouch" -> {
                if (packet is C03PacketPlayer) {
                    val playerBoundingBox = mc.thePlayer!!.entityBoundingBox
                    val bb = mc.thePlayer!!.getEntityBoundingBox().offset(0.0, 0.15, 0.0)
                    if (!mc.theWorld!!.checkBlockCollision(bb)) {
                        packet.y += 0.125
                    }

                }
            }

            "spectate" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                }
            }

            "spectatespoof" -> {
                if (packet is C03PacketPlayer) {
                    packet.onGround = false

                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }

            "spectatespoof2" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }
            "ghostly" -> {
                if (mc.gameSettings.keyBindUseItem.pressed || mc.thePlayer!!.ticksExisted <= 40) return
                if (packet is C03PacketPlayer) {
                    val capabilities = PlayerCapabilities()
                    // capabilities.disableDamage = false
                    capabilities.isFlying = true
                    // capabilities.allowFlying = false
                    capabilities.isCreativeMode = true
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                    PacketUtils.sendPacketNoEvent(C0CPacketInput(1.05F, 1.05F, true, false))
                    debugMessage("Packet C13,C18,C0C")
                }
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                    packetBuffer.add(packet)
                    PacketUtils.sendPacketNoEvent(C0CPacketInput())
                    debugMessage("more ping,C0C")
                }
                if (packet is C00PacketKeepAlive) {
                    debugMessage(packet.key.toString() + "-24")
                    packet.key -= 24
                }
                if (packet is C0BPacketEntityAction) event.cancelEvent()
                if (packet is S08PacketPlayerPosLook) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    debugMessage("silent setback")
                }

            }
            "flying" -> {
                if (packet is C03PacketPlayer) {
                    val capabilities = PlayerCapabilities() // flags=2
                    capabilities.disableDamage = false
                    capabilities.isFlying = true
                    capabilities.allowFlying = false
                    capabilities.isCreativeMode = false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    debugMessage("Packet C13")
                }
            }

            "oldmatrix" -> {
                if (packet is C03PacketPlayer && !(packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook)) {
                    event.cancelEvent()
                }
                if (packet is C02PacketUseEntity || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook ||
                    packet is C06PacketPlayerPosLook || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction
                ) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "fakelag" -> {
                if (fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if (isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        if (lagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        isSent = false
                    }
                    if (packet is C00PacketKeepAlive || packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagAttackValue.get() && (packet is C02PacketUseEntity || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if (packet is C0APacketAnimation) return
                    }
                    if (fakeLagBlockValue.get() && (packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagPosValue.get() && (packet is C03PacketPlayer || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook || packet is C0BPacketEntityAction)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }

            "c13+infinitec0c" -> {
                PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                PacketUtils.sendPacketNoEvent(C0CPacketInput(0.9F, 0.9F, false, false))
            }
            "hypixel2" -> {
                // TODO skid flux client

            }
            "hypixel" -> {
                if(!watchDogAntiBan.get()){
                    if (event.packet is C06PacketPlayerPosLook && mc.thePlayer.onGround && mc.thePlayer.fallDistance>10) {
                        if (counter > 0) {
                            if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                                mc.netHandler.networkManager.sendPacket(C04PacketPlayerPosition(event.packet.x, event.packet.y, event.packet.z, event.packet.onGround))
                                ClientUtils.displayChatMessage("[Disabler] Packet C04")
                                event.cancelEvent()
                            }
                        }
                        counter += 1

                        if (event.packet is C05PacketPlayerLook && mc.thePlayer.isRiding) {
                            mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                            ClientUtils.displayChatMessage("[Disabler] Packet C0B")
                        } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                            mc.netHandler.networkManager.sendPacket(event.packet)
                            mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))
                            ClientUtils.displayChatMessage("[Disabler] Packet C0B")
                            event.cancelEvent()
                        }
                    }

                    if (event.packet is S08PacketPlayerPosLook) {
                        val s08 = event.packet
                        x = s08.x
                        y = s08.y
                        z = s08.z
                        ClientUtils.displayChatMessage("[Disabler] Receive S08")
                    }

                    if (event.packet is S07PacketRespawn) {
                        counter = 0
                    }
                }
            }
        }
    }

    private fun debugMessage(str: String) {
        if (debug.get()) {
            alert(" [Disabler] $str")
        }
    }

    override val tag: String
        get() = modeValue.get()
}
