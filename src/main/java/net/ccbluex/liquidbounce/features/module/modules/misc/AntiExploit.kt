/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/UnlegitMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.misc

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.value.*
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.server.*
import net.minecraft.util.ChatComponentText
import net.minecraft.util.IChatComponent

@ModuleInfo(name = "AntiExploit", category = ModuleCategory.MISC, array = false, defaultOn = true)
class AntiExploit : Module() {

    init {
        state = true
    }
    private val autoleaveValue = BoolValue("AutoQuit", true)
    val blockTeamsPacketValue = BoolValue("blockTeamsPacket", false)
    val hycraftValue = BoolValue("hycraft", false)
    val notifyValue = BoolValue("Notify", false)
    val guardianValue = BoolValue("LessGuardian", true)
    private val maxMobs = IntegerValue("MaxMobSpawn", 50, 20, 100)
    private val maxParticles = IntegerValue("MaxParticles", 40, 10, 100)
    private val maxArrowSpawn = IntegerValue("MaxArrowPerSecond", 100, 1, 1000)

    private var tick = 0
    private var arrowMax = 0
    private var guardianEffect = false
    private var count = 0
    // hicraft variable
    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val team = arrayListOf<S3EPacketTeams>()
    private val particle = arrayListOf<S2APacketParticles>()
    private val item = arrayListOf<S38PacketPlayerListItem>()
    private val chunk = arrayListOf<S21PacketChunkData>()
    private val explosion = arrayListOf<S27PacketExplosion>()
    fun sendMessage(s: String, force: Boolean = false) {
        if (notifyValue.get() || force)
            ClientUtils.displayChatMessage("§7[§a§lAntiExploit§7]§6 $s")
    }

    override fun onDisable() {
        sendMessage("We highly recommend you to keep this module, AntiExploit enabled.", true)
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if(mc.thePlayer!!.ticksExisted % 40 == 0){
            count = 0
            arrowMax = 0
            particle.clear()
            team.clear()
            chunk.clear()
            explosion.clear()
            item.clear()
        }
        if(packet is S0FPacketSpawnMob) {
            count++
            if(count > maxMobs.get()) {
                event.cancelEvent()
                sendMessage("Blocked Mobs : $count")
                crashClient("mobs spawn flood")
            }
        }
        if (packet is S3EPacketTeams && blockTeamsPacketValue.get()) {
            event.cancelEvent()
            sendMessage("teams packet " + packet.players)
        }
        if(packet is S2APacketParticles) {
            if(packet.particleCount > maxParticles.get()) {
                sendMessage("Blocked Particles: " + packet.particleCount)
                event.cancelEvent()
                if(packet.particleCount > 1024) {
                    sendMessage("large particle")
                    crashClient("large particle")
                }
            }
        }
        if (packet is S2BPacketChangeGameState) {
            if (packet.getGameState() == 5 && !mc.isDemo()) {
                event.cancelEvent()
                sendMessage("Illegal Demo GUI.")
                crashClient("illegal demo GUI")
            }
            if (packet.getGameState() == 10 && guardianValue.get()) {
                    event.cancelEvent()
                    sendMessage("Limited Guardian Effect.")
                    crashClient("guardian effect")

            }
        }

        if (packet is S0EPacketSpawnObject && packet.getType() == 60) {
            arrowMax++
            if (arrowMax > maxArrowSpawn.get()) {
                event.cancelEvent()
                sendMessage("Reached max arrow spawn per second.")
                crashClient("arrow spawn flood")
            }
        }
        if (hycraftValue.get()) {
            if (packet is S2APacketParticles) {
                event.cancelEvent()
                particle.add(packet)
            }

            if (packet is S3EPacketTeams) {
                event.cancelEvent()
                team.add(packet)
            }

            if (packet is S27PacketExplosion) {
                event.cancelEvent()
                explosion.add(packet)
            }

            if (packet is S21PacketChunkData) {
                event.cancelEvent()
                chunk.add(packet)
            }

            if (packet is S38PacketPlayerListItem) {
                event.cancelEvent()
                item.add(packet)
            }

            if (particle.size > 70 || team.size > 70 || explosion.size > 70 || chunk.size > 70 || item.size > 70) {
                sendMessage("hycraft crash")
                crashClient("(hycaft multi crash)")
            }

        }
    }


    fun crashClient(type: String){
        if(!autoleaveValue.get()) return
        PacketUtils.handlePacket(
            S40PacketDisconnect(
                ChatComponentText(
                    LiquidBounce.CLIENT_NAME + " - AntiExploit\n" +
                            "\n" +
                            "This server is trying to crash your client with $type\n"+
                            "we stopped them and pretend your client has been crashed\n" +
                            "\n" +
                            "If this is a false positive, disable the Misc/AntiExploit module\n" +
                            "\n"
                )
            )
        )
    }
}